[{"title":"开发 VSCode 扩展","path":"/practices/vscode-extension-dev/","content":"开发 VSCode 扩展环境设置 Node.js — Run JavaScript Everywhere Git 12npm install -g yo generator-codeyo code","tags":["VSCode","Extension Development"],"categories":["practices"]},{"title":"AiriFlow","path":"/devops/airi-flow/","content":"AiriFlow学习微软的 Git 开发流程后，取其糟粕、去其精华（大雾）的个人版本控制流程。 Branch master: 最新的发行版 rls_[version]: 历史版本 dev: 主干开发分支 feat_[name]: 功能分支 fix_[name]: 修复分支 Flow New repository: -&gt; master -&gt; dev New project: -&gt; feature doc -&gt; feature todos -&gt; dev Test feature: fix → merge into dev Test on stage dev: fix in dev → merge into master → test as mirror → patch as rls","tags":["Git","Gitlab","GitHub"],"categories":["devops"]},{"title":"蛋仔派对","path":"/game-devs/eggy/","content":"EggyEggy 项目中踩过的一些坑和其他遇到的东西。 NeoxCocosC++Python 兼容性问题，安装环境时需看全下载 Python 2.718，而不是 Python 2.7。 Python 2 遍历字典时需使用 .iteritems()，range() 使用 xrange() 代替。 使用 &#x2F; 做除法时，如果明确返回的需要是个 int，需要用 &#x2F;&#x2F;。 for 循环里用 lambda 闭包时，对象改变时闭包调用依然时为最终值，可以通过改成函数参数来替代。 Co-worker","tags":["Eggy","NetEase"],"categories":["game"]},{"title":"npm 下载时踩坑网络问题","path":"/mistakes/npm-web-error/","content":"npm 下载时踩坑网络问题: ETIMEDOUT, ECONNREFUSED1npm config set registry https://registry.npmmirror.com","tags":["Nodejs","npm"],"categories":["mistakes"]},{"title":"快速求平方根的倒数","path":"/game-devs/fast-inverse-square-root/","content":"Fast inverse square root快速平方根算法，是一种在 IEEE 754 浮点格式下估计 $\\frac{1}{\\sqrt{x}}$ 的方法。 Most famous case该算法最出名的是 1999 年 约翰·卡马克 在《Quake III Arena》中的实现，其代码如下： 12345678910111213141516float Q_rsqrt( float number )&#123;\tlong i;\tfloat x2, y;\tconst float threehalfs = 1.5F;\tx2 = number * 0.5F;\ty = number;\ti = * ( long * ) &amp;y; // evil floating point bit level hacking\ti = 0x5f3759df - ( i &gt;&gt; 1 ); // what the fuck?\ty = * ( float * ) &amp;i;\ty = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration//\ty = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed\treturn y;&#125; 以上代码中起关键作用的代码如下： i = * ( long * ) &amp;y; ：这是在将浮点数转换为 long 整型。 i = 0x5f3759df - ( i &gt;&gt; 1 ); ：通过一番魔鬼操作，得到 $\\frac{1}{\\sqrt{x}}$ 近似解，下面会讲到。 y = * ( float * ) &amp;i; ：这是在将整型转换回浮点型。 y = y * ( threehalfs - ( x2 * y * y ) ); ：用牛顿法迭代更精确的结果，上面代码中只用了一次牛顿法就得到了符合 float 类型精度要求的结果，因此注释掉了后面的代码。 Motivation浮点数的平方根倒数通常用于对矢量进行归一化，这在计算机图形学中有着广泛的应用，但浮点数平方根和除法相对于乘法成本较高，快速平方根倒数算法绕过了这两个步骤，从而具有性能优势。 AlgorithmIEEE 754 Float要理解这个算法，首先要了解 IEEE 754 规范下的 32位（单精度）浮点型存储方式。 符号位（sign bit）：0 表示正数，1 表示负数，通常在最高位。科学计数法存储，整数位永远为1。 指数位（exponent）：有8位（double float 为11位），可以为值 0~255（$2^{8} - 1$），值127表示指数为0，因此能表示 $2^{-126}$ 到 $2^{127}$。 尾数位（mantissa）：存储数值的实际有效数字，有 23位，尾数用来表示一个介于 1~2（不包括 2） 之间的数，但最高位（隐含的”1”）通常不存储，因为除了在特殊情况（如0、infinities、NaN）外，它总是1。 该浮点数的值计算公式如下： $$x &#x3D; (-1)^{Si} \\cdot (1 + \\frac{M}{L}) \\cdot 2^{(E - B)} \\tag{1} % Float$$ 其中常数 $L &#x3D; 2^{23}$ （即尾数 23 位能表示的最大值 $+ 1$），$B &#x3D; 127$（即指数位能表示的最大值 $&#x2F; 2 - 1$）。 对于图中的浮点数，符号位 $Si &#x3D; 0_2 &#x3D; 0$，指数位$E &#x3D; 0111\\ 1100_2 &#x3D; 124$，尾数位 $M &#x3D; 010\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000_2 &#x3D; 0.25 \\times 2^{23}$ 带入公式得当前浮点数 $x &#x3D; 1 \\cdot (1 + 0.25) \\cdot 2^{-3} &#x3D; 0.15625$。 当我们对这浮点数作为 int 进行类型重解释时，得如下结果： $$I_{x} &#x3D; (-1)^{Si} \\cdot (E \\times L + M) \\tag{2} % Int$$ Aliasing to an integer as an approximate logarithm对于想求的浮点数 $y &#x3D; \\frac{1}{\\sqrt{x}}$ 的 x，由于应用场景限制，不会出现需要对平方根进行解析延拓的情况，因此可以认为 x、y 中标志位 $Si &#x3D; 0$ 恒成立。 再对公式 1 的 $x &#x3D; (1 + \\frac{M}{L}) \\cdot 2^{(E - B)}$ 取对数，得到 $\\log_{2}{x} &#x3D; E - B + \\log_{2}{(1 + \\frac{M}{L})}$ 然后，由于 $\\frac{M}{L} \\in [0,1)$ 时，$\\log_{2}{(1 + \\frac{M}{L})} \\approx \\frac{M}{L} + \\sigma$ 即： $$\\log_{2}{x} \\approx E - B + \\frac{M}{L} + \\sigma \\tag{3} \\approx \\frac{I_x}{L} - B + \\sigma % Approximate$$ 那，如果我们跳过直接求 $y &#x3D; \\frac{1}{\\sqrt{x}}$，改成求 y 被视为 Int 类型后的近似表示 $I_y$，可以得到 $$\\begin{align*}y &#x3D; \\frac{1}{\\sqrt{x}}\\\\log_{2}{y} &#x3D; -\\frac{1}{2}\\log_{2}{x}\\\\frac{I_y}{L} - B + \\sigma \\approx -\\frac{1}{2}(\\frac{I_x}{L} - B + \\sigma)\\I_y \\approx \\frac{3}{2}L(B - \\sigma) - \\frac{1}{2}I_x\\end{align*}$$ 对应的代码就是 1i = 0x5f3759df - ( i &gt;&gt; 1 ); 再讨论一下 $\\sigma$，上面代码中实际 $\\sigma \\approx 0.0450466$，如果为 0，易得$\\frac{3}{2}L(B - \\sigma) &#x3D; 0x5f400000$，$\\sigma$ 的取值关乎 float 被视为 int 后 $I_x$ 与 $L(B + \\log_{2}{x} - \\sigma)$ 实际的接近程度，如果基于数学计算， $\\sigma$ 理论最优值为^1 $$\\sigma &#x3D; \\frac{1}{2} − \\frac{1 +\\ln(\\ln(2))}{2\\ln(2)} \\approx 0.0430357$$ Newton’s method牛顿法可以在有根的近似解的情况下提高精度。要求要有第一个近似值，且附近连续可导。 求 $y &#x3D; \\frac{1}{\\sqrt{x}}$ 可以视为求 $f(y) &#x3D; \\frac{1}{y^2} - x$ 的根。用上面方法找到第一个近似值，对于近似值 $y_n$ 总能找到更好的近似值 $y_{n + 1} &#x3D; y_n - \\frac{f(y_n)}{f’(y_n)}$，即 $$y_{n + 1} &#x3D; y_n(\\frac{3 - xy^2_n)}{2})$$对应的就是 1y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration Additional了解算法即可，硬件上的优化以至于它现在没什么用了。","tags":["Algorithm"],"categories":["game"]},{"title":"语言类型划分","path":"/langs/language-classification/","content":"Languages ClassificationDifference Between Compiled Languages, Interpreted Languages编译型语言需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。 编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。 编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。 C、C++、Pascal、Object-C、swift。 解释型语言解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。 有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。 每次运行的时候都要解释一遍，性能上不如编译型语言。 JavaScript、Python、Erlang、PHP、Perl、Ruby。 混合型语言 既有需要次次编译项目难以热更新的缺点。。。性能上也不如原生的 C、C++。通常也归为解释型语言。 Java、C#。 Difference Between Dynamic Typed Languages, Static Typed Languages动态类型语言动态类型语言是指在运行期间才去做数据类型检查的语言，数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。 Python、Ruby、Erlang、JavaScript、swift、PHP、Perl。 静态类型语言静态语言的数据类型是在编译其间确定的或者说运行之前确定的，编写代码的时候要明确确定变量的数据类型。 C、C++、C#、Java、Object-C。 Difference Between Strong Typed Languages, Weak Typed Languages强类型语言强类型语言，必须显式的写明类型转换，才能作为其他类型处理。 Java、C#、Python、Object-C、Ruby。 弱类型语言编译器或运行时有隐式的类型转换处理，因此要注意可能会有 string + int 但不报错的情况。 Difference Between Dynamic Languages, Static Languages动态语言动态语言典型的特征为运行时可以改变其结构，比如 eval函数、对象运行时机改变、类型推论、可变内存分配、反射和宏。 JavaScript、PHP、Ruby、Python。 静态语言","tags":["Algorithm"],"categories":["langs"]},{"title":"Hexo 部署","path":"/practices/deploy-hexo/","content":"Hexo 部署环境设置 Node.js — Run JavaScript Everywhere。 Git。 123456npm install -g hexo-clihexo initgit submodule add https://github.com/xaoxuu/hexo-theme-stellar.git themes/stellarcd themes/stellargit checkout tags/1.29.1npm install hexo-deployer-git --save 命令1234npm run buildnpm run cleannpm run servernpm run deploy 格式 个人使用 Hexo 写文习惯。 模板12345678910---title: &lt;utf8_string&gt;date: &lt;year&gt; &quot;-&quot; &lt;month&gt; &quot;-&quot; &lt;day&gt;url: &lt;kebab-case-lowercase-string&gt;categories: [&lt;kebab-case-lowercase-string&gt;, ]tags: [&lt;utf8_string&gt;, ]references: [&lt;string&gt; ::= &quot;[&lt;url_title&gt;](&lt;url&gt;)&quot;, ]---# &lt;title&gt; 文法 见 中文文案排版指北。 踩坑IDE 预览大多数主题都支持额外的渲染标签，但换主题和 IDE 预览一致性上比较麻烦，个人还是写几个常用的简单的 HTML 标签 Snippet 更方便。 相对复杂的还确实需要用到那没办法了。有条件且需要可以给 IDE 写插件改渲染。 HTMLPREVIEW ERROR： 123&lt;div&gt;**content**&lt;/div&gt; 大部分解析器会把 “**” 显示出来 PREVIEW RIGHT： 12345&lt;div&gt;**content**&lt;/div&gt; 这样处理基本上都会按 Markdown 语法进行渲染。","tags":["GitHub","Hexo"],"categories":["practices"]},{"path":"/about/index.html","content":"dadaf"},{"path":"/explore/index.html","content":"Uncategorized小叽资源https://steamzg.comSwitch520https://www.gamer520.comACG港湾https://www.acggw.club量子ACGhttps://lzacg.org梓澪の妙妙屋https://zi0.cc搜图Bot酱 (soutubot.moe)https://soutubot.moe 搜索相关ChatGPThttps://chatgpt.comDuckDuckGohttps://duckduckgo.comGooglehttps://www.google.comBinghttps://www.bing.comYandex — a fast Internet searchhttps://yandex.com 番相关Motrixhttps://github.com/agalwood/Motrix/releasesVCB-Studiohttps://vcb-s.com萌番组https://bangumi.moeBangumi 番组计划https://bangumi.tv新番列表https://miroko.cn ip 相关猫猫云https://5maomao.xyzSMS-虚拟号码https://sms-activate.org/cn"},{"title":"Hatsune Miku Coder","path":"/wiki/htsn-miku-coder/index.html","content":"Hatsune Miku Coder Hatsune Miku Coder 是一个 VS Code 扩展插件，它提供基于 OpenAI 的代码建议和自动补全功能。 Environment Requirements Ollama: any, VS Code: 1.95.0及以上版本（在这个版本开发和自测的，其他版本不知道） Ollama下载链接：https://ollama.com/download推荐模型：极低显存（4G以下） 1ollama run llama3.2:3b https://ollama.com/library/llama3.2:3b 1ollama run gemma2:2b https://ollama.com/library/gemma2:2b 1ollama run llava-phi3:3.8b https://ollama.com/library/llava-phi3:3.8b 较低显存（8G以下） 1ollama run qwen2.5:7b https://ollama.com/library/qwen2.5 1ollama run gemma2:9b 1ollama run qwen2.5-coder:7b https://ollama.com/library/qwen2.5-coder:7b 1ollama run llama2:13b https://ollama.com/library/llama2:13b 1ollama run llama3.2-vision:11b https://ollama.com/library/llama3.2-vision:11b 图像支持 1ollama run llava:13b https://ollama.com/library/llava:13b 图像支持 中等显存（16G以下） 卡在这段的似乎比较少，动不动就 20G 以上了 1ollama run qwen2.5:14b https://ollama.com/library/qwen2.5:14b 1ollama run granite-code:20b https://ollama.com/library/granite-code:20b 1ollama run mistral-small:22b https://ollama.com/library/mistral-small:22b 插件设置值 HtsnMikuCoder.Ollama.port: 11434 or ollama server HtsnMikuCoder.Ollama.model: granite-code:20b 快捷键 HtsnMikuCoder.Command.CodeCompletion: Ctrl+Shift+Alt+S HtsnMikuCoder.Command.AbortOllama: Ctrl+Shift+Alt+A HtsnMikuCoder.Command.ChatInMarkdown: Ctrl+Shift+Alt+C Features代码补全Markdown 中聊天TODO 支持代码补全功能 支持一些值的配置 整理聊天时的格式规则 实现 Markdown 中的聊天功能"},{"title":"CHANGELOG","path":"/wiki/htsn-miku-coder/CHANGELOG.html","content":"CHANGELOGUnreleasedv0.1.0-alphafeatures 实现了基于 Markdown 上下文聊天，但约定格式不太合理，后续重构 实现了代码补全功能，但值几乎都是写死在代码里"}]